name: Secret Leak Reproduction Test

on:
  workflow_dispatch:
    inputs:
      wait_seconds:
        description: "Seconds to wait before printing the secret (gives time to change it)"
        required: false
        default: "30"

jobs:
  test-secret-masking:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Capture secret early
        env:
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "=== Step 1: Secret captured at job start ==="
          echo "Secret length: ${#THE_SECRET}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

          # Store the secret value in a file for later steps
          # (simulates a real workflow that passes secrets between steps)
          echo "$THE_SECRET" > /tmp/captured_secret.txt
          echo "Secret captured and stored for later use."

      - name: Wait for secret to be changed externally
        env:
          WAIT_SECONDS: ${{ github.event.inputs.wait_seconds }}
        run: |
          echo "=== Step 2: Waiting ${WAIT_SECONDS}s for secret to be changed externally ==="
          echo "Start: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Change the TEST_SECRET repo secret NOW using:"
          echo "  gh secret set TEST_SECRET -R <owner>/<repo> --body '<new-value>'"
          echo ""

          # Countdown so you can see progress in live logs
          for i in $(seq "$WAIT_SECONDS" -1 1); do
            if [ $((i % 10)) -eq 0 ] || [ "$i" -le 5 ]; then
              echo "  Waiting... ${i}s remaining"
            fi
            sleep 1
          done
          echo "Done waiting: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

      - name: Print captured secret via echo
        run: |
          echo "=== Step 3: Printing the originally-captured secret ==="
          CAPTURED=$(cat /tmp/captured_secret.txt)
          echo "Direct echo of captured secret:"
          echo "$CAPTURED"

      - name: Print secret via env var (re-injected)
        env:
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "=== Step 4: Printing secret from env var (re-injected by Actions) ==="
          echo "From env var:"
          echo "$THE_SECRET"

      - name: Print secret character by character
        run: |
          echo "=== Step 5: Printing captured secret char by char ==="
          CAPTURED=$(cat /tmp/captured_secret.txt)
          echo "Char-by-char output:"
          for (( i=0; i<${#CAPTURED}; i++ )); do
            printf "%s" "${CAPTURED:$i:1}"
          done
          echo ""

      - name: Print secret in base64
        run: |
          echo "=== Step 6: Printing captured secret in base64 ==="
          CAPTURED=$(cat /tmp/captured_secret.txt)
          echo "Base64 encoded:"
          echo "$CAPTURED" | base64
          echo "Hex encoded:"
          echo "$CAPTURED" | xxd -p

      - name: Print secret reversed
        run: |
          echo "=== Step 7: Printing captured secret reversed ==="
          CAPTURED=$(cat /tmp/captured_secret.txt)
          echo "Reversed:"
          echo "$CAPTURED" | rev

      - name: Print secret with spaces between chars
        run: |
          echo "=== Step 8: Printing captured secret with spaces ==="
          CAPTURED=$(cat /tmp/captured_secret.txt)
          echo "With spaces:"
          echo "$CAPTURED" | sed 's/./& /g'

      - name: Summary
        run: |
          echo "=== Test Complete ==="
          echo "Check the log output above."
          echo "If any step shows the secret value in clear text (not '***'),"
          echo "then the masking bug has been reproduced."
          echo ""
          echo "Expected behavior: ALL secret values should show as '***'"
          echo "Bug behavior: Old secret value appears in clear text after being changed"
