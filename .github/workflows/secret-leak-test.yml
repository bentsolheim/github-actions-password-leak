name: Secret Leak Reproduction Test

on:
  workflow_dispatch:
    inputs:
      wait_seconds:
        description: "Seconds to wait before printing the secret (gives time to change it)"
        required: false
        default: "30"

jobs:
  # ==========================================================================
  # TEST A: Masking bypass via encoding/transformation
  # Systematically tests which representations of a secret value are masked.
  # GitHub masks the literal string and base64, but may miss other encodings.
  # ==========================================================================
  test-masking-transforms:
    runs-on: ubuntu-latest
    steps:
      - name: Store secret for transforms
        env:
          SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "=== Masking Transform Test ==="
          echo "Secret length: ${#SECRET}"
          printf '%s' "$SECRET" > /tmp/secret.txt

      # --- Hex encodings ---
      - name: "Transform: hex-xxd"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "HEX_XXD: $(printf '%s' "$S" | xxd -p | tr -d '\n')"

      - name: "Transform: hex-od"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "HEX_OD: $(printf '%s' "$S" | od -A n -t x1 | tr -d ' \n')"

      - name: "Transform: hex-printf"
        run: |
          S=$(cat /tmp/secret.txt)
          OUT=""
          for (( i=0; i<${#S}; i++ )); do
            OUT+=$(printf '%02x' "'${S:$i:1}")
          done
          echo "HEX_PRINTF: $OUT"

      # --- Octal encoding ---
      - name: "Transform: octal"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "OCTAL: $(printf '%s' "$S" | od -A n -t o1 | tr -d ' \n')"

      # --- Decimal ASCII codes ---
      - name: "Transform: decimal-ascii"
        run: |
          S=$(cat /tmp/secret.txt)
          OUT=""
          for (( i=0; i<${#S}; i++ )); do
            OUT+="$(printf '%d ' "'${S:$i:1}")"
          done
          echo "DECIMAL_ASCII: $OUT"

      # --- Base64 variants ---
      - name: "Transform: base64-no-newline"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "B64_NO_NL: $(printf '%s' "$S" | base64)"

      - name: "Transform: base64-with-newline"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "B64_WITH_NL: $(echo "$S" | base64)"

      - name: "Transform: base64-chunks"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "B64_WRAP16: $(printf '%s' "$S" | base64 -w 16)"

      - name: "Transform: base32"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "BASE32: $(printf '%s' "$S" | base32)"

      # --- URL encoding ---
      - name: "Transform: url-encode"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "URL_ENCODE: $(python3 -c "import urllib.parse; print(urllib.parse.quote('$S'))")"

      - name: "Transform: url-encode-all"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "URL_ENCODE_ALL: $(python3 -c "import urllib.parse; print(urllib.parse.quote('$S', safe=''))")"

      # --- HTML entity encoding ---
      - name: "Transform: html-entities"
        run: |
          S=$(cat /tmp/secret.txt)
          OUT=$(python3 -c "
          s = open('/tmp/secret.txt').read()
          print(''.join(f'&#{ord(c)};' for c in s))
          ")
          echo "HTML_ENTITIES: $OUT"

      # --- Unicode escapes ---
      - name: "Transform: unicode-escapes"
        run: |
          S=$(cat /tmp/secret.txt)
          OUT=$(python3 -c "
          s = open('/tmp/secret.txt').read()
          print(''.join(f'\\\\u{ord(c):04x}' for c in s))
          ")
          echo "UNICODE_ESC: $OUT"

      # --- String manipulation transforms ---
      - name: "Transform: reversed"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "REVERSED: $(echo "$S" | rev)"

      - name: "Transform: spaced-chars"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "SPACED: $(echo "$S" | sed 's/./& /g')"

      - name: "Transform: one-char-per-line"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "CHARS_PER_LINE:"
          echo "$S" | grep -o .

      - name: "Transform: rot13"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "ROT13: $(echo "$S" | tr 'a-zA-Z' 'n-za-mN-ZA-M')"

      - name: "Transform: uppercase"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "UPPER: $(echo "$S" | tr '[:lower:]' '[:upper:]')"

      - name: "Transform: caesar-shift-1"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "CAESAR1: $(echo "$S" | tr 'a-zA-Z0-9' 'b-za-aB-ZA-A1-90')"

      # --- Substring / partial exposure ---
      - name: "Transform: first-half"
        run: |
          S=$(cat /tmp/secret.txt)
          HALF=$(( ${#S} / 2 ))
          echo "FIRST_HALF: ${S:0:$HALF}"

      - name: "Transform: second-half"
        run: |
          S=$(cat /tmp/secret.txt)
          HALF=$(( ${#S} / 2 ))
          echo "SECOND_HALF: ${S:$HALF}"

      - name: "Transform: every-other-char"
        run: |
          S=$(cat /tmp/secret.txt)
          EVEN=""
          ODD=""
          for (( i=0; i<${#S}; i++ )); do
            if (( i % 2 == 0 )); then
              EVEN+="${S:$i:1}"
            else
              ODD+="${S:$i:1}"
            fi
          done
          echo "EVEN_CHARS: $EVEN"
          echo "ODD_CHARS: $ODD"

      - name: "Transform: 4char-chunks"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "CHUNKS_4:"
          echo "$S" | fold -w 4 | while read -r chunk; do
            echo "  $chunk"
          done

      # --- Structured data embedding ---
      - name: "Transform: json-value"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "JSON_VAL: $(python3 -c "import json; print(json.dumps({'token': '$S'}))")"

      - name: "Transform: key-value"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "KEY_VALUE: token=$S"

      - name: "Transform: in-url"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "IN_URL: https://api.example.com/v1/auth?token=$S&format=json"

      - name: "Transform: in-connection-string"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "CONN_STR: postgres://admin:$S@db.example.com:5432/mydb"

      # --- Binary representation ---
      - name: "Transform: binary"
        run: |
          S=$(cat /tmp/secret.txt)
          OUT=$(python3 -c "
          s = open('/tmp/secret.txt').read()
          print(' '.join(f'{ord(c):08b}' for c in s))
          ")
          echo "BINARY: $OUT"

      # --- Digest / hash based (non-reversible but tests masking) ---
      - name: "Transform: hashes"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "MD5: $(printf '%s' "$S" | md5sum | cut -d' ' -f1)"
          echo "SHA1: $(printf '%s' "$S" | sha1sum | cut -d' ' -f1)"
          echo "SHA256: $(printf '%s' "$S" | sha256sum | cut -d' ' -f1)"

      # --- Control: literal and base64 (should be masked) ---
      - name: "Transform: control-literal"
        run: |
          S=$(cat /tmp/secret.txt)
          echo "LITERAL: $S"

      - name: "Transform: control-base64-standard"
        env:
          SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "CONTROL_B64: $(printf '%s' "$SECRET" | base64)"

      - name: Summary
        run: |
          echo "=== Transform Test Complete ==="
          echo "Check which HEX_, OCTAL_, B64_, etc. lines appear in cleartext vs ***"

  # ==========================================================================
  # TEST B: Original single-job rotation test (kept for reference)
  # ==========================================================================
  test-secret-rotation:
    runs-on: ubuntu-latest
    steps:
      - name: Capture secret early
        env:
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "$THE_SECRET" > /tmp/captured_secret.txt
          echo "=== Rotation test: secret captured ==="

      - name: Wait for secret to be changed externally
        env:
          WAIT_SECONDS: ${{ github.event.inputs.wait_seconds }}
        run: |
          echo "=== Waiting ${WAIT_SECONDS}s ==="
          for i in $(seq "$WAIT_SECONDS" -1 1); do
            if [ $((i % 10)) -eq 0 ] || [ "$i" -le 5 ]; then
              echo "  Waiting... ${i}s remaining"
            fi
            sleep 1
          done

      - name: Print captured secret
        run: |
          CAPTURED=$(cat /tmp/captured_secret.txt)
          echo "Direct: $CAPTURED"

  # ==========================================================================
  # TEST C: Multi-job artifact handoff (V1 via artifact to post-rotation job)
  # ==========================================================================
  capture-secret:
    runs-on: ubuntu-latest
    steps:
      - name: Capture and upload
        env:
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          mkdir -p /tmp/secret-artifact
          echo "$THE_SECRET" > /tmp/secret-artifact/captured.txt
          echo "=== Captured secret to artifact ==="

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: captured-secret
          path: /tmp/secret-artifact/captured.txt
          retention-days: 1

      - name: Wait for rotation
        env:
          WAIT_SECONDS: ${{ github.event.inputs.wait_seconds }}
        run: |
          echo "=== Waiting ${WAIT_SECONDS}s for rotation ==="
          sleep "$WAIT_SECONDS"

  print-from-artifact:
    needs: capture-secret
    runs-on: ubuntu-latest
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: captured-secret
          path: /tmp/secret-artifact

      - name: Print V1 from artifact
        run: |
          CAPTURED=$(cat /tmp/secret-artifact/captured.txt)
          echo "ARTIFACT_LITERAL: $CAPTURED"
          echo "ARTIFACT_HEX: $(printf '%s' "$CAPTURED" | xxd -p | tr -d '\n')"
          echo "ARTIFACT_B64: $(printf '%s' "$CAPTURED" | base64)"
          echo "ARTIFACT_B64NL: $(echo "$CAPTURED" | base64)"
