name: Secret Leak Reproduction Test

on:
  workflow_dispatch:
    inputs:
      wait_seconds:
        description: "Seconds to wait before printing the secret (gives time to change it)"
        required: false
        default: "30"

jobs:
  # ==========================================================================
  # TEST 1: Original rotation test (single job)
  # Theory: Runner masks V1, secret rotated to V2, V1 may leak
  # ==========================================================================
  test-secret-rotation:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Capture secret early
        env:
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "=== Step 1: Secret captured at job start ==="
          echo "Secret length: ${#THE_SECRET}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "$THE_SECRET" > /tmp/captured_secret.txt
          echo "Secret captured and stored for later use."

      - name: Wait for secret to be changed externally
        env:
          WAIT_SECONDS: ${{ github.event.inputs.wait_seconds }}
        run: |
          echo "=== Step 2: Waiting ${WAIT_SECONDS}s for secret to be changed externally ==="
          echo "Start: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          for i in $(seq "$WAIT_SECONDS" -1 1); do
            if [ $((i % 10)) -eq 0 ] || [ "$i" -le 5 ]; then
              echo "  Waiting... ${i}s remaining"
            fi
            sleep 1
          done
          echo "Done waiting: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

      - name: Print captured secret via echo
        run: |
          echo "=== Step 3: Printing the originally-captured secret ==="
          CAPTURED=$(cat /tmp/captured_secret.txt)
          echo "Direct echo of captured secret:"
          echo "$CAPTURED"

      - name: Print secret via env var (re-injected)
        env:
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "=== Step 4: Printing secret from env var (re-injected by Actions) ==="
          echo "From env var:"
          echo "$THE_SECRET"

      - name: Summary
        run: |
          echo "=== Rotation Test Complete ==="
          echo "If any value above shows in clear text, the rotation bug is confirmed."

  # ==========================================================================
  # TEST 2: Multi-job artifact passing
  # Theory: Job 1 captures V1 into an artifact. Secret is rotated to V2.
  # Job 2 starts on a FRESH runner whose masking dict only has V2.
  # Job 2 downloads the artifact containing V1 and prints it → V1 LEAKS.
  # ==========================================================================
  capture-secret:
    runs-on: ubuntu-latest
    steps:
      - name: Capture secret and upload as artifact
        env:
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "=== Capture Job: Saving secret to artifact ==="
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Secret length: ${#THE_SECRET}"
          mkdir -p /tmp/secret-artifact
          echo "$THE_SECRET" > /tmp/secret-artifact/captured.txt

      - name: Upload captured secret as artifact
        uses: actions/upload-artifact@v4
        with:
          name: captured-secret
          path: /tmp/secret-artifact/captured.txt
          retention-days: 1

      - name: Wait for external secret rotation
        env:
          WAIT_SECONDS: ${{ github.event.inputs.wait_seconds }}
        run: |
          echo "=== Waiting ${WAIT_SECONDS}s for secret rotation ==="
          echo "Rotate the secret NOW so Job 2 gets a fresh runner with V2"
          for i in $(seq "$WAIT_SECONDS" -1 1); do
            if [ $((i % 10)) -eq 0 ] || [ "$i" -le 5 ]; then
              echo "  Waiting... ${i}s remaining"
            fi
            sleep 1
          done
          echo "Done waiting. Job 2 should start with rotated secret."

  print-from-artifact:
    needs: capture-secret
    runs-on: ubuntu-latest
    steps:
      - name: Download captured secret artifact
        uses: actions/download-artifact@v4
        with:
          name: captured-secret
          path: /tmp/secret-artifact

      - name: Print original secret from artifact
        run: |
          echo "=== Artifact Job: Printing V1 from artifact ==="
          echo "This runner started AFTER secret rotation."
          echo "Its masking dict should only contain V2."
          echo "If V1 appears in cleartext below, the bug is confirmed."
          echo ""
          CAPTURED=$(cat /tmp/secret-artifact/captured.txt)
          echo "Captured value: $CAPTURED"
          echo "Length: ${#CAPTURED}"

      - name: Print current secret for comparison
        env:
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "=== Current secret (should be V2, masked as ***) ==="
          echo "Current: $THE_SECRET"
          echo "Length: ${#THE_SECRET}"

      - name: Print artifact secret in various formats
        run: |
          CAPTURED=$(cat /tmp/secret-artifact/captured.txt)
          echo "=== Artifact secret in various formats ==="
          echo "Direct: $CAPTURED"
          echo "In URL: https://api.example.com/auth?token=$CAPTURED"
          echo "Base64: $(printf '%s' "$CAPTURED" | base64)"
          echo "Hex: $(printf '%s' "$CAPTURED" | xxd -p)"

  # ==========================================================================
  # TEST 3: Continuous output during rotation window
  # Theory: Tight loop printing the secret while rotation happens increases
  # the chance of hitting a race between log upload and masking update.
  # ==========================================================================
  test-continuous-output:
    runs-on: ubuntu-latest
    steps:
      - name: Capture secret
        env:
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "$THE_SECRET" > /tmp/captured_secret.txt

      - name: Continuously print secret during rotation window
        env:
          WAIT_SECONDS: ${{ github.event.inputs.wait_seconds }}
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "=== Continuous Output Test ==="
          echo "Printing secret every second for ${WAIT_SECONDS}s"
          echo "If rotation causes masking to drop, one of these will leak."
          CAPTURED=$(cat /tmp/captured_secret.txt)
          for i in $(seq 1 "$WAIT_SECONDS"); do
            echo "[t+${i}s] env: $THE_SECRET | file: $CAPTURED"
            sleep 1
          done
          echo "=== Continuous output complete ==="

  # ==========================================================================
  # TEST 4: Large log buffer flush then print
  # Theory: Filling the log buffer forces a flush/upload to GitHub's servers.
  # If the secret value is in a chunk that gets uploaded right as masking
  # patterns change, the server may not mask V1 in that chunk.
  # ==========================================================================
  test-buffer-flush:
    runs-on: ubuntu-latest
    steps:
      - name: Capture secret
        env:
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: echo "$THE_SECRET" > /tmp/captured_secret.txt

      - name: Wait for rotation window
        env:
          WAIT_SECONDS: ${{ github.event.inputs.wait_seconds }}
        run: |
          echo "=== Waiting ${WAIT_SECONDS}s ==="
          sleep "$WAIT_SECONDS"

      - name: Flush log buffer then print secret
        run: |
          echo "=== Buffer Flush Test ==="
          CAPTURED=$(cat /tmp/captured_secret.txt)
          # Generate a large block of output to flush log buffers
          for i in $(seq 1 500); do
            echo "PADDING LINE $i: $(head -c 200 /dev/urandom | base64 | tr -d '\n')"
          done
          # Now immediately print the secret — it should be in a fresh buffer chunk
          echo "SECRET_AFTER_FLUSH: $CAPTURED"
          # Print again with more padding interleaved
          for i in $(seq 1 100); do
            echo "PAD $i $(head -c 100 /dev/urandom | base64 | tr -d '\n')"
            if [ $((i % 10)) -eq 0 ]; then
              echo "INTERLEAVED_SECRET: $CAPTURED"
            fi
          done

  # ==========================================================================
  # TEST 5: Late rotation — change secret DURING the print steps
  # The reproduce.sh script will coordinate a second rotation timed to happen
  # while this job is actively printing. Uses a long print phase.
  # ==========================================================================
  test-late-rotation:
    runs-on: ubuntu-latest
    steps:
      - name: Capture secret early
        env:
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "$THE_SECRET" > /tmp/captured_secret.txt
          echo "=== Late Rotation Test: Secret captured ==="
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

      - name: Short wait then extended print phase
        env:
          WAIT_SECONDS: ${{ github.event.inputs.wait_seconds }}
        run: |
          echo "=== Waiting half the time, then entering print phase ==="
          HALF=$((WAIT_SECONDS / 2))
          sleep "$HALF"
          echo "=== Entering print phase (rotate secret NOW) ==="
          echo "PRINT_PHASE_START: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          CAPTURED=$(cat /tmp/captured_secret.txt)
          # Print repeatedly over the remaining time
          REMAINING=$((WAIT_SECONDS - HALF))
          for i in $(seq 1 "$REMAINING"); do
            echo "[print t+${i}s] secret=$CAPTURED"
            sleep 1
          done
          echo "PRINT_PHASE_END: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

  # ==========================================================================
  # TEST 6: GITHUB_OUTPUT and step output passing
  # Theory: Passing via GITHUB_OUTPUT exercises a different code path.
  # The output may be re-evaluated when accessed in a later step.
  # ==========================================================================
  test-output-passing:
    runs-on: ubuntu-latest
    steps:
      - name: Store secret in GITHUB_OUTPUT
        id: capture
        env:
          THE_SECRET: ${{ secrets.TEST_SECRET }}
        run: |
          echo "=== Storing secret in GITHUB_OUTPUT ==="
          echo "value=$THE_SECRET" >> "$GITHUB_OUTPUT"
          echo "Secret stored in step output."

      - name: Wait for rotation
        env:
          WAIT_SECONDS: ${{ github.event.inputs.wait_seconds }}
        run: |
          echo "=== Waiting ${WAIT_SECONDS}s ==="
          sleep "$WAIT_SECONDS"

      - name: Read from step output after rotation
        run: |
          echo "=== Reading from step output ==="
          echo "Output value: ${{ steps.capture.outputs.value }}"

      - name: Read via env var from step output
        env:
          CAPTURED: ${{ steps.capture.outputs.value }}
        run: |
          echo "=== Via env var from output ==="
          echo "Value: $CAPTURED"
          echo "Length: ${#CAPTURED}"
